# SHA256d FPGA Miner (Educational Sample)

本リポジトリは、SHA256 および SHA256d（Double SHA256）を FPGA 上で実装・検証するための教育用サンプルプロジェクトです。

商用マイニング用途を目的としたものではなく、以下を主な目的としています。

* SHA256 圧縮関数の構造理解
* FPGA における整数加算・キャリー伝搬の挙動理解
* パイプライン設計および並列化手法の学習
* Verilator を用いた RTL 単体検証フローの習得

---

## 特徴

* SystemVerilog による SHA256 ラウンドコア実装
* Carry-Save Adder（CSA）を用いた多項加算の最適化例
* Verilator による C++ テストベンチ検証
* GitHub Actions 等への展開を想定したシンプルなビルド構成

加算器の設計やパイプライン段数を変更することで、
Fmax・面積・スループットのトレードオフを観察できます。

---

## ディレクトリ構成

```
src/
  rtl/
    sha256d/
      sha256_round_core.sv

  sim/
    sha256d/
      tb_sha256_round_core.cpp

build/
```

* `rtl/` : RTL 実装
* `sim/` : Verilator 用 C++ テストベンチ
* `build/` : ビルド生成物（自動生成）

---

## ビルドとテスト

必要環境:

* Verilator
* g++ (C++17 対応)
* make

テスト実行:

```bash
make clean
make test
```

成功すると `PASS` が表示され、波形ファイル（VCD）が生成されます。

---

## 実装方針

### 1. SHA256 ラウンド単体から検証

最初に 1 ラウンド分のコアを実装し、
参照実装（C++）と照合することで論理の正しさを確認します。

### 2. 多項加算の最適化

SHA256 の T1 計算は 5 項加算になります。

```
T1 = h + Σ1(e) + Ch(e,f,g) + K[i] + W[i]
```

単純な直列加算ではキャリー伝搬がクリティカルパスになりやすいため、
Carry-Save Adder（CSA）で中間和を畳み込み、最終段でのみキャリー伝搬加算を行う構成としています。

### 3. 教育目的の設計

* DSP ブロックに依存しない構成
* 合成ツール依存の最適化に頼らない記述
* ロジック構造が追いやすい実装

実際の性能最適化は対象デバイスやツールに強く依存します。
本リポジトリはその出発点としての参考実装です。

---

## 今後の拡張予定

* 64 ラウンド圧縮関数の実装
* SHA256d（2 回目の SHA）統合
* midstate 対応
* 並列ワーカー構成
* 合成レポート比較例の追加

---

## ライセンス

教育目的のサンプルとして公開予定です。
詳細は LICENSE ファイルを参照してください。

---

本プロジェクトは、FPGA によるハッシュ回路設計の理解を深めるための
堅実なサンプル実装を目指しています。
